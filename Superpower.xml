<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Superpower</name>
    </assembly>
    <members>
        <member name="T:Superpower.Combinators">
            <summary>
            Functions that construct more complex parsers by combining simpler ones.
            </summary>
        </member>
        <member name="M:Superpower.Combinators.Apply``2(Superpower.TokenListParser{``0,Superpower.Model.Token{``0}},System.Func{Superpower.Model.Token{``0},Superpower.TextParser{``1}})">
            <summary>
            Apply the character parser <paramref name="valueParser"/> to the span represented by the parsed token.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <param name="parser">The parser.</param>
            <param name="valueParser">A function that determines which character parser to apply.</param>
            <returns>A parser that returns the result of parsing the token value.</returns>
        </member>
        <member name="M:Superpower.Combinators.Apply``2(Superpower.TokenListParser{``0,Superpower.Model.Token{``0}},Superpower.TextParser{``1})">
            <summary>
            Apply the character parser <paramref name="valueParser"/> to the span represented by the parsed token.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <param name="parser">The parser.</param>
            <param name="valueParser">A character parser to apply.</param>
            <returns>A parser that returns the result of parsing the token value.</returns>
        </member>
        <member name="M:Superpower.Combinators.AtEnd``1(Superpower.TextParser{``0})">
            <summary>
            Construct a parser that succeeds only if the source is at the end of input.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.AtEnd``2(Superpower.TokenListParser{``0,``1})">
            <summary>
            Construct a parser that succeeds only if the source is at the end of input.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.AtLeastOnce``2(Superpower.TokenListParser{``0,``1})">
            <summary>
            Construct a parser that matches one or more instances of applying <paramref name="parser"/>.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.AtLeastOnce``1(Superpower.TextParser{``0})">
            <summary>
            Construct a parser that matches one or more instances of applying <paramref name="parser"/>.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.AtLeastOnceDelimitedBy``3(Superpower.TokenListParser{``0,``1},Superpower.TokenListParser{``0,``2})">
            <summary>
            Construct a parser that matches one or more instances of applying <paramref name="parser"/>, delimited by <paramref name="delimiter"/>.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <param name="parser">The parser.</param>
            <param name="delimiter">The parser that matches the delimiters.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.AtLeastOnceDelimitedBy``2(Superpower.TextParser{``0},Superpower.TextParser{``1})">
            <summary>
            Construct a parser that matches one or more instances of applying <paramref name="parser"/>, delimited by <paramref name="delimiter"/>.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <param name="parser">The parser.</param>
            <param name="delimiter">The parser that matches the delimiters.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.IgnoreThen``3(Superpower.TokenListParser{``0,``1},Superpower.TokenListParser{``0,``2})">
            <summary>
            Construct a parser that matches <paramref name="first"/>, discards the resulting value, then returns the result of <paramref name="second"/>.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <param name="first">The first parser.</param>
            <param name="second">The second parser.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.IgnoreThen``2(Superpower.TextParser{``0},Superpower.TextParser{``1})">
            <summary>
            Construct a parser that matches <paramref name="first"/>, discards the resulting value, then returns the result of <paramref name="second"/>.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <param name="first">The first parser.</param>
            <param name="second">The second parser.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Many``2(Superpower.TokenListParser{``0,``1})">
            <summary>
            Construct a parser that matches <paramref name="parser"/> zero or more times.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <returns>The resulting parser.</returns>
            <remarks>Many will fail if any item partially matches this. To modify this behavior use <see cref="M:Superpower.Combinators.Try``2(Superpower.TokenListParser{``0,``1})"/>.</remarks>
        </member>
        <member name="M:Superpower.Combinators.Many``1(Superpower.TextParser{``0})">
            <summary>
            Construct a parser that matches <paramref name="parser"/> zero or more times.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <returns>The resulting parser.</returns>
            <remarks>Many will fail if any item partially matches this. To modify this behavior use <see cref="M:Superpower.Combinators.Try``1(Superpower.TextParser{``0})"/>.</remarks>
        </member>
        <member name="M:Superpower.Combinators.ManyDelimitedBy``3(Superpower.TokenListParser{``0,``1},Superpower.TokenListParser{``0,``2})">
            <summary>
            Construct a parser that matches <paramref name="parser"/> zero or more times, delimited by <paramref name="delimiter"/>.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <param name="parser">The parser.</param>
            <param name="delimiter">The parser that matches the delimiters.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.ManyDelimitedBy``2(Superpower.TextParser{``0},Superpower.TextParser{``1})">
            <summary>
            Construct a parser that matches <paramref name="parser"/> zero or more times, delimited by <paramref name="delimiter"/>.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <param name="parser">The parser.</param>
            <param name="delimiter">The parser that matches the delimiters.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Message``2(Superpower.TokenListParser{``0,``1},System.String)">
            <summary>
            Construct a parser that fails with error message <paramref name="errorMessage"/> when <paramref name="parser"/> fails.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <param name="errorMessage">The error message.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Message``1(Superpower.TextParser{``0},System.String)">
            <summary>
            Construct a parser that fails with error message <paramref name="errorMessage"/> when <paramref name="parser"/> fails.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <param name="errorMessage">The error message.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Named``2(Superpower.TokenListParser{``0,``1},System.String)">
            <summary>
            Construct a parser that returns <paramref name="name"/> as its "expectation" if <paramref name="parser"/> fails.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <param name="name">The name given to <paramref name="parser"/>.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Named``1(Superpower.TextParser{``0},System.String)">
            <summary>
            Construct a parser that returns <paramref name="name"/> as its "expectation" if <paramref name="parser"/> fails.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <param name="name">The name given to <paramref name="parser"/>.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Optional``2(Superpower.TokenListParser{``0,``1})">
            <summary>
            Construct a parser that matches zero or one instance of <paramref name="parser"/>.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Optional``1(Superpower.TextParser{``0})">
            <summary>
            Construct a parser that matches zero or one instance of <paramref name="parser"/>.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.OptionalOrDefault``2(Superpower.TokenListParser{``0,``1},``1)">
            <summary>
            Construct a parser that matches zero or one instance of <paramref name="parser"/>, returning <paramref name="defaultValue"/> when
            no match is possible.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <param name="defaultValue">The default value</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.OptionalOrDefault``1(Superpower.TextParser{``0},``0)">
            <summary>
            Construct a parser that matches zero or one instance of <paramref name="parser"/>, returning <paramref name="defaultValue"/> when
            no match is possible.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <param name="defaultValue">The default value.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Or``2(Superpower.TokenListParser{``0,``1},Superpower.TokenListParser{``0,``1})">
            <summary>
            Construct a parser that tries first the <paramref name="lhs"/> parser, and if it fails, applies <paramref name="rhs"/>.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="lhs">The first parser to try.</param>
            <param name="rhs">The second parser to try.</param>
            <returns>The resulting parser.</returns>
            <remarks>Or will fail if the first item partially matches this. To modify this behavior use <see cref="M:Superpower.Combinators.Try``2(Superpower.TokenListParser{``0,``1})"/>.</remarks>
        </member>
        <member name="M:Superpower.Combinators.Or``1(Superpower.TextParser{``0},Superpower.TextParser{``0})">
            <summary>
            Construct a parser that tries first the <paramref name="lhs"/> parser, and if it fails, applies <paramref name="rhs"/>.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="lhs">The first parser to try.</param>
            <param name="rhs">The second parser to try.</param>
            <returns>The resulting parser.</returns>
            <remarks>Or will fail if the first item partially matches this. To modify this behavior use <see cref="M:Superpower.Combinators.Try``1(Superpower.TextParser{``0})"/>.</remarks>
        </member>
        <member name="M:Superpower.Combinators.Select``3(Superpower.TokenListParser{``0,``1},System.Func{``1,``2})">
            <summary>
            Construct a parser that takes the result of <paramref name="parser"/> and converts it value using <paramref name="selector"/>.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <param name="parser">The parser.</param>
            <param name="selector">A mapping from the first result to the second.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Select``2(Superpower.TextParser{``0},System.Func{``0,``1})">
            <summary>
            Construct a parser that takes the result of <paramref name="parser"/> and converts it value using <paramref name="selector"/>.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <param name="parser">The parser.</param>
            <param name="selector">A mapping from the first result to the second.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.SelectMany``3(Superpower.TextParser{``0},System.Func{``0,Superpower.TextParser{``1}},System.Func{``0,``1,``2})">
            <summary>
            The LINQ query comprehension pattern.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <typeparam name="V"></typeparam>
            <param name="parser">The parser.</param>
            <param name="selector">A mapping from the first result to the second parser.</param>
            <param name="projector">Function mapping the results of the first two parsers onto the final result.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.SelectMany``4(Superpower.TokenListParser{``0,``1},System.Func{``1,Superpower.TokenListParser{``0,``2}},System.Func{``1,``2,``3})">
            <summary>
            The LINQ query comprehension pattern.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <typeparam name="V"></typeparam>
            <param name="parser">The parser.</param>
            <param name="selector">A mapping from the first result to the second parser.</param>
            <param name="projector">Function mapping the results of the first two parsers onto the final result.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Then``3(Superpower.TokenListParser{``0,``1},System.Func{``1,Superpower.TokenListParser{``0,``2}})">
            <summary>
            Construct a parser that applies <paramref name="first"/>, provides the value to <paramref name="second"/> and returns the result.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <param name="first">The first parser.</param>
            <param name="second">The second parser.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Then``2(Superpower.TextParser{``0},System.Func{``0,Superpower.TextParser{``1}})">
            <summary>
            Construct a parser that applies <paramref name="first"/>, provides the value to <paramref name="second"/> and returns the result.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <param name="first">The first parser.</param>
            <param name="second">The second parser.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Try``2(Superpower.TokenListParser{``0,``1})">
            <summary>
            Construct a parser that tries one parser, and backtracks if unsuccessful so that no input
            appears to have been consumed by subsequent checks against the result.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Try``1(Superpower.TextParser{``0})">
            <summary>
            Construct a parser that tries one parser, and backtracks if unsuccessful so that no input
            appears to have been consumed by subsequent checks against the result.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Value``3(Superpower.TokenListParser{``0,``1},``2)">
            <summary>
            Construct a parser that applies the first, and returns <paramref name="value"/>.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <param name="parser">The parser.</param>
            <param name="value">The value to return.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Value``2(Superpower.TextParser{``0},``1)">
            <summary>
            Construct a parser that applies the first, and returns <paramref name="value"/>.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <param name="parser">The parser.</param>
            <param name="value">The value to return.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Where``2(Superpower.TokenListParser{``0,``1},System.Func{``1,System.Boolean})">
            <summary>
            Construct a parser that evaluates the result of a previous parser and fails if <paramref name="predicate"/> returns false
            for the result.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <param name="predicate">The predicate to apply.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Where``1(Superpower.TextParser{``0},System.Func{``0,System.Boolean})">
            <summary>
            Construct a parser that evaluates the result of a previous parser and fails if <paramref name="predicate"/> returns false
            for the result.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <param name="predicate">The predicate to apply.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="T:Superpower.Display.TokenAttribute">
            <summary>
            Applied to enum members representing tokens to control how they are rendered.
            </summary>
        </member>
        <member name="P:Superpower.Display.TokenAttribute.Category">
            <summary>
            The category of the token, e.g. "keyword" or "identifier".
            </summary>
        </member>
        <member name="P:Superpower.Display.TokenAttribute.Example">
            <summary>
            For tokens that correspond to exact text, e.g. punctuation, the canonical
            example of how the token looks.
            </summary>
        </member>
        <member name="P:Superpower.Display.TokenAttribute.Description">
            <summary>
            A description of the token, for example "regular expression".
            </summary>
        </member>
        <member name="T:Superpower.Model.Position">
            <summary>
            A position within a stream of character input.
            </summary>
        </member>
        <member name="P:Superpower.Model.Position.Absolute">
            <summary>
            The zero-based absolute index of the position.
            </summary>
        </member>
        <member name="P:Superpower.Model.Position.Line">
            <summary>
            The one-based line number.
            </summary>
        </member>
        <member name="P:Superpower.Model.Position.Column">
            <summary>
            The one-based column number.
            </summary>
        </member>
        <member name="M:Superpower.Model.Position.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Construct a position.
            </summary>
            <param name="absolute">The absolute position.</param>
            <param name="line">The line number.</param>
            <param name="column">The column number.</param>
        </member>
        <member name="P:Superpower.Model.Position.Zero">
            <summary>
            The position corresponding to the zero index.
            </summary>
        </member>
        <member name="P:Superpower.Model.Position.Empty">
            <summary>
            A position with no value.
            </summary>
        </member>
        <member name="P:Superpower.Model.Position.HasValue">
            <summary>
            True if the position has a value.
            </summary>
        </member>
        <member name="M:Superpower.Model.Position.Advance(System.Char)">
            <summary>
            Advance over <paramref name="overChar"/>, advancing line and column numbers
            as appropriate.
            </summary>
            <param name="overChar">The character being advanced over.</param>
            <returns>The updated position.</returns>
        </member>
        <member name="M:Superpower.Model.Position.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Superpower.Model.Result">
            <summary>
            Helper methods for working with <see cref="T:Superpower.Model.Result`1"/>.
            </summary>
        </member>
        <member name="M:Superpower.Model.Result.Empty``1(Superpower.Model.TextSpan)">
            <summary>
            An empty result indicating no value could be parsed.
            </summary>
            <typeparam name="T">The result type.</typeparam>
            <param name="remainder">The start of un-parsed input.</param>
            <returns>A result.</returns>
        </member>
        <member name="M:Superpower.Model.Result.Empty``1(Superpower.Model.TextSpan,System.String[])">
            <summary>
            An empty result indicating no value could be parsed.
            </summary>
            <typeparam name="T">The result type.</typeparam>
            <param name="remainder">The start of un-parsed input.</param>
            <param name="expectations">Literal descriptions of expectations not met.</param>
            <returns>A result.</returns>
        </member>
        <member name="M:Superpower.Model.Result.Empty``1(Superpower.Model.TextSpan,System.String)">
            <summary>
            An empty result indicating no value could be parsed.
            </summary>
            <typeparam name="T">The result type.</typeparam>
            <param name="remainder">The start of un-parsed input.</param>
            <param name="errorMessage">Error message to present.</param>
            <returns>A result.</returns>
        </member>
        <member name="M:Superpower.Model.Result.Value``1(``0,Superpower.Model.TextSpan,Superpower.Model.TextSpan)">
            <summary>
            A result carrying a successfully-parsed value.
            </summary>
            <typeparam name="T">The result type.</typeparam>
            <param name="value">The value.</param>
            <param name="location">The location corresponding to the beginning of the parsed span.</param>
            <param name="remainder">The start of un-parsed input.</param>
            <returns>A result.</returns>
        </member>
        <member name="M:Superpower.Model.Result.CastEmpty``2(Superpower.Model.Result{``0})">
            <summary>
            Convert an empty result of one type into another.
            </summary>
            <typeparam name="T">The source type.</typeparam>
            <typeparam name="U">The target type.</typeparam>
            <param name="result">The value to convert.</param>
            <returns>A result of type <typeparamref name="U"/> carrying the same information as <paramref name="result"/>.</returns>
        </member>
        <member name="M:Superpower.Model.Result.CombineEmpty``1(Superpower.Model.Result{``0},Superpower.Model.Result{``0})">
            <summary>
            Combine two empty results.
            </summary>
            <typeparam name="T">The source type.</typeparam>
            <param name="first">The first value to combine.</param>
            <param name="second">The second value to combine.</param>
            <returns>A result of type <typeparamref name="T"/> carrying information from both results.</returns>
        </member>
        <member name="T:Superpower.Model.Result`1">
            <summary>
            The result of parsing from a text span.
            </summary>
            <typeparam name="T">The type of the value being parsed.</typeparam>
        </member>
        <member name="P:Superpower.Model.Result`1.Location">
            <summary>
            The location in the stream where the parsing began (== the input).
            </summary>
        </member>
        <member name="P:Superpower.Model.Result`1.Remainder">
            <summary>
            The first un-parsed location in the stream.
            </summary>
        </member>
        <member name="P:Superpower.Model.Result`1.HasValue">
            <summary>
            True if the result carries a successfully-parsed value; otherwise, false.
            </summary>
        </member>
        <member name="P:Superpower.Model.Result`1.ErrorPosition">
            <summary>
            The position of the first un-parsed location.
            </summary>
        </member>
        <member name="P:Superpower.Model.Result`1.ErrorMessage">
            <summary>
            A provided error message, or null.
            </summary>
        </member>
        <member name="P:Superpower.Model.Result`1.Expectations">
            <summary>
            A list of expectations that were unmet, or null.
            </summary>
        </member>
        <member name="P:Superpower.Model.Result`1.Value">
            <summary>
            The parsed value.
            </summary>
        </member>
        <member name="M:Superpower.Model.Result`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:Superpower.Model.Result`1.FormatErrorMessageFragment">
            <summary>
            If the result is empty, format the fragment of text describing the error.
            </summary>
            <returns>The error fragment.</returns>
        </member>
        <member name="T:Superpower.Model.TextSpan">
            <summary>
            A span of text within a larger string.
            </summary>
        </member>
        <member name="P:Superpower.Model.TextSpan.Source">
            <summary>
            The source string containing the span.
            </summary>
        </member>
        <member name="P:Superpower.Model.TextSpan.Position">
            <summary>
            The position of the start of the span within the string.
            </summary>
        </member>
        <member name="P:Superpower.Model.TextSpan.Length">
            <summary>
            The length of the span.
            </summary>
        </member>
        <member name="M:Superpower.Model.TextSpan.#ctor(System.String)">
            <summary>
            Construct a span encompassing an entire string.
            </summary>
            <param name="source">The source string.</param>
        </member>
        <member name="M:Superpower.Model.TextSpan.#ctor(System.String,Superpower.Model.Position,System.Int32)">
            <summary>
            Construct a string span for a substring of <paramref name="source"/>.
            </summary>
            <param name="source">The source string.</param>
            <param name="position">The start of the span.</param>
            <param name="length">The length of the span.</param>
        </member>
        <member name="P:Superpower.Model.TextSpan.None">
            <summary>
            A span with no value.
            </summary>
        </member>
        <member name="P:Superpower.Model.TextSpan.Empty">
            <summary>
            A span corresponding to the empty string.
            </summary>
        </member>
        <member name="P:Superpower.Model.TextSpan.IsAtEnd">
            <summary>
            True if the span has no content.
            </summary>
        </member>
        <member name="M:Superpower.Model.TextSpan.ConsumeChar">
            <summary>
            Consume a character from the start of the span.
            </summary>
            <returns>A result with the character and remainder.</returns>
        </member>
        <member name="M:Superpower.Model.TextSpan.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Superpower.Model.TextSpan.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Superpower.Model.TextSpan.Equals(Superpower.Model.TextSpan)">
            <summary>
            Compare a string span with another using source identity semantics - same source, same position, same length.
            </summary>
            <param name="other">The other span.</param>
            <returns>True if the spans are the same.</returns>
        </member>
        <member name="M:Superpower.Model.TextSpan.op_Equality(Superpower.Model.TextSpan,Superpower.Model.TextSpan)">
            <summary>
            Compare two spans using source identity semantics.
            </summary>
            <param name="lhs">One span.</param>
            <param name="rhs">Another span.</param>
            <returns>True if the spans are the same.</returns>
        </member>
        <member name="M:Superpower.Model.TextSpan.op_Inequality(Superpower.Model.TextSpan,Superpower.Model.TextSpan)">
            <summary>
            Compare two spans using source identity semantics.
            </summary>
            <param name="lhs">One span.</param>
            <param name="rhs">Another span.</param>
            <returns>True if the spans are the different.</returns>
        </member>
        <member name="M:Superpower.Model.TextSpan.Until(Superpower.Model.TextSpan)">
            <summary>
            Return a new span from the start of this span to the beginning of another.
            </summary>
            <param name="next">The next span.</param>
            <returns>A sub-span.</returns>
        </member>
        <member name="M:Superpower.Model.TextSpan.First(System.Int32)">
            <summary>
            Return a span comprising the first <paramref name="length"/> characters of this span.
            </summary>
            <param name="length">The number of characters to return.</param>
            <returns>The sub-span.</returns>
        </member>
        <member name="M:Superpower.Model.TextSpan.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Superpower.Model.TextSpan.ToStringValue">
            <summary>
            Compute the string value of this span.
            </summary>
            <returns>A string with the value of this span.</returns>
        </member>
        <member name="M:Superpower.Model.TextSpan.EqualsValue(System.String)">
            <summary>
            Compare the contents of this span with <paramref name="otherValue"/>.
            </summary>
            <param name="otherValue">The string value to compare.</param>
            <returns>True if the values are the same.</returns>
        </member>
        <member name="M:Superpower.Model.TextSpan.EqualsValueIgnoreCase(System.String)">
            <summary>
            Compare the contents of this span with <paramref name="otherValue"/>, ignoring invariant character case.
            </summary>
            <param name="otherValue">The string value to compare.</param>
            <returns>True if the values are the same ignoring case.</returns>
        </member>
        <member name="T:Superpower.Model.TokenListParserResult">
            <summary>
            Helper methods for working with <see cref="T:Superpower.Model.TokenListParserResult`2"/>.
            </summary>
        </member>
        <member name="M:Superpower.Model.TokenListParserResult.Empty``2(Superpower.Model.TokenList{``0})">
            <summary>
            Create a token result with no value, indicating a failure to parse any value.
            </summary>
            <typeparam name="TKind">The kind of token.</typeparam>
            <typeparam name="T">The result type.</typeparam>
            <param name="remainder">The start of un-parsed input.</param>
            <returns>An empty result.</returns>
        </member>
        <member name="M:Superpower.Model.TokenListParserResult.Empty``2(Superpower.Model.TokenList{``0},System.String[])">
            <summary>
            Create a token result with no value, indicating a failure to parse any value.
            </summary>
            <typeparam name="TKind">The kind of token.</typeparam>
            <typeparam name="T">The result type.</typeparam>
            <param name="remainder">The start of un-parsed input.</param>
            <param name="expectations">Expectations that could not be fulfilled.</param>
            <returns>An empty result.</returns>
        </member>
        <member name="M:Superpower.Model.TokenListParserResult.Empty``2(Superpower.Model.TokenList{``0},System.String)">
            <summary>
            Create a token result with no value, indicating a failure to parse any value.
            </summary>
            <typeparam name="TKind">The kind of token.</typeparam>
            <typeparam name="T">The result type.</typeparam>
            <param name="remainder">The start of un-parsed input.</param>
            <param name="errorMessage">An error message describing why the tokens could not be parsed.</param>
            <returns>An empty result.</returns>
        </member>
        <member name="M:Superpower.Model.TokenListParserResult.Empty``2(Superpower.Model.TokenList{``0},Superpower.Model.Position,System.String)">
            <summary>
            Create a token result with no value, indicating a failure to parse any value.
            </summary>
            <typeparam name="TKind">The kind of token.</typeparam>
            <typeparam name="T">The result type.</typeparam>
            <param name="remainder">The start of un-parsed input.</param>
            <param name="errorPosition">A source position within an individual token where parsing failed. In this case the position will be within
            the first token in <paramref name="remainder"/>.</param>
            <param name="errorMessage">A message describing the problem.</param>
            <returns>An empty result.</returns>
        </member>
        <member name="M:Superpower.Model.TokenListParserResult.Value``2(``1,Superpower.Model.TokenList{``0},Superpower.Model.TokenList{``0})">
            <summary>
            Create a token result with the provided value.
            </summary>
            <typeparam name="TKind">The kind of token.</typeparam>
            <typeparam name="T">The result type.</typeparam>
            <param name="value">The value.</param>
            <param name="location">The location where parsing began.</param>
            <param name="remainder">The first un-parsed location.</param>
            <returns></returns>
        </member>
        <member name="M:Superpower.Model.TokenListParserResult.CastEmpty``3(Superpower.Model.TokenListParserResult{``0,``1})">
            <summary>
            Convert an empty result of one type into another.
            </summary>
            <typeparam name="TKind">The kind of token.</typeparam>
            <typeparam name="T">The source type.</typeparam>
            <typeparam name="U">The destination type.</typeparam>
            <param name="result">The result to convert.</param>
            <returns>The converted result.</returns>
        </member>
        <member name="M:Superpower.Model.TokenListParserResult.CombineEmpty``2(Superpower.Model.TokenListParserResult{``0,``1},Superpower.Model.TokenListParserResult{``0,``1})">
            <summary>
            Combine two empty results.
            </summary>
            <typeparam name="T">The source type.</typeparam>
            <typeparam name="TKind">The kind of token.</typeparam>
            <param name="first">The first value to combine.</param>
            <param name="second">The second value to combine.</param>
            <returns>A result of type <typeparamref name="T"/> carrying information from both results.</returns>
        </member>
        <member name="T:Superpower.Model.TokenListParserResult`2">
            <summary>
            The result of parsing from a token list.
            </summary>
            <typeparam name="T">The type of the value being parsed.</typeparam>
            <typeparam name="TKind">The kind of token being parsed.</typeparam>
        </member>
        <member name="P:Superpower.Model.TokenListParserResult`2.Location">
            <summary>
            The location in the stream where the parsing began.
            </summary>
        </member>
        <member name="P:Superpower.Model.TokenListParserResult`2.Remainder">
            <summary>
            The first un-parsed location in the stream.
            </summary>
        </member>
        <member name="P:Superpower.Model.TokenListParserResult`2.HasValue">
            <summary>
            True if the result carries a successfully-parsed value; otherwise, false.
            </summary>
        </member>
        <member name="P:Superpower.Model.TokenListParserResult`2.ErrorPosition">
            <summary>
            The position of the first un-parsed location.
            </summary>
        </member>
        <member name="P:Superpower.Model.TokenListParserResult`2.ErrorMessage">
            <summary>
            A provided error message, or null.
            </summary>
        </member>
        <member name="P:Superpower.Model.TokenListParserResult`2.Expectations">
            <summary>
            A list of expectations that were unmet, or null.
            </summary>
        </member>
        <member name="P:Superpower.Model.TokenListParserResult`2.Value">
            <summary>
            The parsed value.
            </summary>
        </member>
        <member name="M:Superpower.Model.TokenListParserResult`2.ToString">
            <inheritdoc />
        </member>
        <member name="M:Superpower.Model.TokenListParserResult`2.FormatErrorMessageFragment">
            <summary>
            If the result is empty, format the fragment of text describing the error.
            </summary>
            <returns>The error fragment.</returns>
        </member>
        <member name="T:Superpower.Model.TokenList`1">
            <summary>
            A list of <see cref="T:Superpower.Model.Token`1"/>
            </summary>
            <typeparam name="TKind">The kind of tokens held in the list.</typeparam>
        </member>
        <member name="P:Superpower.Model.TokenList`1.Position">
            <summary>
            The position of the token list in the token stream.
            </summary>
        </member>
        <member name="M:Superpower.Model.TokenList`1.#ctor(Superpower.Model.Token{`0}[])">
            <summary>
            Construct a token list containing <paramref name="tokens"/>.
            </summary>
            <param name="tokens">The tokens in the list.</param>
        </member>
        <member name="P:Superpower.Model.TokenList`1.Empty">
            <summary>
            A token list with no value.
            </summary>
        </member>
        <member name="P:Superpower.Model.TokenList`1.IsAtEnd">
            <summary>
            True if the token list contains no tokens.
            </summary>
        </member>
        <member name="M:Superpower.Model.TokenList`1.ConsumeToken">
            <summary>
            Consume a token from the start of the list, returning a result with the token and remainder.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Superpower.Model.TokenList`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Superpower.Model.TokenList`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Superpower.Model.TokenList`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Superpower.Model.TokenList`1.Equals(Superpower.Model.TokenList{`0})">
            <summary>
            Compare two token lists using identity semantics - same list, same position.
            </summary>
            <param name="other">The other token list.</param>
            <returns>True if the token lists are the same.</returns>
        </member>
        <member name="M:Superpower.Model.TokenList`1.op_Equality(Superpower.Model.TokenList{`0},Superpower.Model.TokenList{`0})">
            <summary>
            Compare two token lists using identity semantics.
            </summary>
            <param name="lhs">The first token list.</param>
            <param name="rhs">The second token list.</param>
            <returns>True if the token lists are the same.</returns>
        </member>
        <member name="M:Superpower.Model.TokenList`1.op_Inequality(Superpower.Model.TokenList{`0},Superpower.Model.TokenList{`0})">
            <summary>
            Compare two token lists using identity semantics.
            </summary>
            <param name="lhs">The first token list.</param>
            <param name="rhs">The second token list.</param>
            <returns>True if the token lists are the different.</returns>
        </member>
        <member name="M:Superpower.Model.TokenList`1.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Superpower.Model.Token`1">
            <summary>
            A token.
            </summary>
            <typeparam name="TKind">The type of the token's kind.</typeparam>
        </member>
        <member name="P:Superpower.Model.Token`1.Kind">
            <summary>
            The kind of the token.
            </summary>
        </member>
        <member name="P:Superpower.Model.Token`1.Span">
            <summary>
            The string span containing the value of the token.
            </summary>
        </member>
        <member name="M:Superpower.Model.Token`1.ToStringValue">
            <summary>
            Get the string value of the token.
            </summary>
            <returns>The token as a string.</returns>
        </member>
        <member name="P:Superpower.Model.Token`1.Position">
            <summary>
            The position of the token within the source string.
            </summary>
        </member>
        <member name="P:Superpower.Model.Token`1.HasValue">
            <summary>
            True if the token has a value.
            </summary>
        </member>
        <member name="M:Superpower.Model.Token`1.#ctor(`0,Superpower.Model.TextSpan)">
            <summary>
            Construct a token.
            </summary>
            <param name="kind">The kind of the token.</param>
            <param name="span">The span holding the token's value.</param>
        </member>
        <member name="P:Superpower.Model.Token`1.Empty">
            <summary>
            A token with no value.
            </summary>
        </member>
        <member name="M:Superpower.Model.Token`1.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Superpower.Model.Unit">
            <summary>
            A structure with no information.
            </summary>
        </member>
        <member name="P:Superpower.Model.Unit.Value">
            <summary>
            The singleton value of the struct, with no value.
            </summary>
        </member>
        <member name="T:Superpower.Parse">
            <summary>
            General parsing helper methods.
            </summary>
        </member>
        <member name="M:Superpower.Parse.Chain``2(Superpower.TextParser{``1},Superpower.TextParser{``0},System.Func{``1,``0,``0,``0})">
            <summary>
            Parse a sequence of operands connected by left-associative operators.
            </summary>
            <typeparam name="T">The type being parsed.</typeparam>
            <typeparam name="TOperator">The type of the operator.</typeparam>
            <param name="operator">A parser matching operators.</param>
            <param name="operand">A parser matching operands.</param>
            <param name="apply">A function combining an operator and two operands into the result.</param>
            <returns>The result of calling <paramref name="apply"/> successively on pairs of operands.</returns>
        </member>
        <member name="M:Superpower.Parse.ChainRight``2(Superpower.TextParser{``1},Superpower.TextParser{``0},System.Func{``1,``0,``0,``0})">
            <summary>
            Parse a sequence of operands connected by right-associative operators.
            </summary>
            <typeparam name="T">The type being parsed.</typeparam>
            <typeparam name="TOperator">The type of the operator.</typeparam>
            <param name="operator">A parser matching operators.</param>
            <param name="operand">A parser matching operands.</param>
            <param name="apply">A function combining an operator and two operands into the result.</param>
            <returns>The result of calling <paramref name="apply"/> successively on pairs of operands.</returns>
        </member>
        <member name="M:Superpower.Parse.Chain``3(Superpower.TokenListParser{``0,``2},Superpower.TokenListParser{``0,``1},System.Func{``2,``1,``1,``1})">
            <summary>
            Parse a sequence of operands connected by left-associative operators.
            </summary>
            <typeparam name="T">The type being parsed.</typeparam>
            <typeparam name="TOperator">The type of the operator.</typeparam>
            <typeparam name="TKind">The kind of token being parsed.</typeparam>
            <param name="operator">A parser matching operators.</param>
            <param name="operand">A parser matching operands.</param>
            <param name="apply">A function combining an operator and two operands into the result.</param>
            <returns>The result of calling <paramref name="apply"/> successively on pairs of operands.</returns>
        </member>
        <member name="M:Superpower.Parse.ChainRight``3(Superpower.TokenListParser{``0,``2},Superpower.TokenListParser{``0,``1},System.Func{``2,``1,``1,``1})">
            <summary>
            Parse a sequence of operands connected by right-associative operators.
            </summary>
            <typeparam name="T">The type being parsed.</typeparam>
            <typeparam name="TOperator">The type of the operator.</typeparam>
            <typeparam name="TKind">The kind of token being parsed.</typeparam>
            <param name="operator">A parser matching operators.</param>
            <param name="operand">A parser matching operands.</param>
            <param name="apply">A function combining an operator and two operands into the result.</param>
            <returns>The result of calling <paramref name="apply"/> successively on pairs of operands.</returns>
        </member>
        <member name="M:Superpower.Parse.Not``1(Superpower.TextParser{``0})">
            <summary>
            Constructs a parser that will fail if the given parser succeeds,
            and will succeed if the given parser fails. In any case, it won't
            consume any input. It's like a negative look-ahead in a regular expression.
            </summary>
            <typeparam name="T">The result type of the given parser</typeparam>
            <param name="parser">The parser to wrap</param>
            <returns>A parser that is the negation of the given parser.</returns>
        </member>
        <member name="M:Superpower.Parse.Not``2(Superpower.TokenListParser{``0,``1})">
            <summary>
            Constructs a parser that will fail if the given parser succeeds,
            and will succeed if the given parser fails. In any case, it won't
            consume any input. It's like a negative look-ahead in a regular expression.
            </summary>
            <typeparam name="T">The result type of the given parser.</typeparam>
            <typeparam name="TKind">The kind of token being parsed.</typeparam>
            <param name="parser">The parser to wrap</param>
            <returns>A parser that is the negation of the given parser.</returns>
        </member>
        <member name="M:Superpower.Parse.Ref``1(System.Func{Superpower.TextParser{``0}})">
            <summary>
            Lazily construct a parser, so that circular dependencies are possible.
            </summary>
            <param name="reference">A function creating the parser, when required.</param>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <returns>A parser that lazily evaluates <paramref name="reference"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="reference"/> is null.</exception>
        </member>
        <member name="M:Superpower.Parse.Ref``2(System.Func{Superpower.TokenListParser{``0,``1}})">
            <summary>
            Lazily construct a parser, so that circular dependencies are possible.
            </summary>
            <param name="reference">A function creating the parser, when required.</param>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="TKind">The kind of token being parsed.</typeparam>
            <returns>A parser that lazily evaluates <paramref name="reference"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="reference"/> is null.</exception>
        </member>
        <member name="M:Superpower.Parse.Return``1(``0)">
            <summary>
            Construct a parser with a fixed value.
            </summary>
            <param name="value">The value returned by the parser.</param>
            <typeparam name="T">The type of <paramref name="value"/>.</typeparam>
            <returns>The parser.</returns>
        </member>
        <member name="M:Superpower.Parse.Return``2(``1)">
            <summary>
            Construct a parser with a fixed value.
            </summary>
            <param name="value">The value returned by the parser.</param>
            <typeparam name="T">The type of <paramref name="value"/>.</typeparam>
            <typeparam name="TKind">The kind of token being parsed.</typeparam>
            <returns>The parser.</returns>
        </member>
        <member name="T:Superpower.ParseException">
            <summary>
            Represents an error that occurs during parsing.
            </summary>
        </member>
        <member name="M:Superpower.ParseException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Superpower.ParseException" /> class.
            </summary>
        </member>
        <member name="M:Superpower.ParseException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Superpower.ParseException" /> class with a specified error message.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Superpower.ParseException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Superpower.ParseException" /> class with a specified error message 
            and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception, 
            or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
        </member>
        <member name="T:Superpower.ParserExtensions">
            <summary>
            Helper methods for working with parsers.
            </summary>
        </member>
        <member name="M:Superpower.ParserExtensions.TryParse``1(Superpower.TextParser{``0},System.String)">
            <summary>
            Tries to parse the input without throwing an exception upon failure.
            </summary>
            <typeparam name="T">The type of the result.</typeparam>
            <param name="parser">The parser.</param>
            <param name="input">The input.</param>
            <returns>The result of the parser</returns>
        </member>
        <member name="M:Superpower.ParserExtensions.TryParse``2(Superpower.TokenListParser{``0,``1},Superpower.Model.TokenList{``0})">
            <summary>
            Tries to parse the input without throwing an exception upon failure.
            </summary>
            <typeparam name="TKind">The type of tokens consumed by the parser.</typeparam>
            <typeparam name="T">The type of the result.</typeparam>
            <param name="parser">The parser.</param>
            <param name="input">The input.</param>
            <returns>The result of the parser</returns>
        </member>
        <member name="M:Superpower.ParserExtensions.Parse``1(Superpower.TextParser{``0},System.String)">
            <summary>
            Parses the specified input string.
            </summary>
            <typeparam name="T">The type of the result.</typeparam>
            <param name="parser">The parser.</param>
            <param name="input">The input.</param>
            <returns>The result of the parser.</returns>
            <exception cref="T:Superpower.ParseException">It contains the details of the parsing error.</exception>
        </member>
        <member name="M:Superpower.ParserExtensions.Parse``2(Superpower.TokenListParser{``0,``1},Superpower.Model.TokenList{``0})">
            <summary>
            Parses the specified input.
            </summary>
            <typeparam name="TKind">The type of tokens consumed by the parser.</typeparam>
            <typeparam name="T">The type of the result.</typeparam>
            <param name="parser">The parser.</param>
            <param name="input">The input.</param>
            <returns>The result of the parser.</returns>
            <exception cref="T:Superpower.ParseException">It contains the details of the parsing error.</exception>
        </member>
        <member name="T:Superpower.Parsers.Character">
            <summary>
            Parsers for matching individual characters.
            </summary>
        </member>
        <member name="M:Superpower.Parsers.Character.Matching(System.Func{System.Char,System.Boolean},System.String)">
            <summary>
            Parse a single character matching <paramref name="predicate"/>.
            </summary>
        </member>
        <member name="M:Superpower.Parsers.Character.Except(System.Func{System.Char,System.Boolean},System.String)">
            <summary>
            Parse a single character except those matching <paramref name="predicate"/>.
            </summary>
            <param name="predicate">Characters not to match.</param>
            <param name="description">Description of characters that don't match.</param>
            <returns>A parser for characters except those matching <paramref name="predicate"/>.</returns>
        </member>
        <member name="M:Superpower.Parsers.Character.EqualTo(System.Char)">
            <summary>
            Parse a single specified character.
            </summary>
        </member>
        <member name="M:Superpower.Parsers.Character.EqualToIgnoreCase(System.Char)">
            <summary>
            Parse a single specified character, ignoring case differences.
            </summary>
        </member>
        <member name="M:Superpower.Parsers.Character.In(System.Char[])">
            <summary>
            Parse any single character in <paramref name="chars"/>.
            </summary>
        </member>
        <member name="M:Superpower.Parsers.Character.Except(System.Char)">
            <summary>
            Parse a single character except <paramref name="ch"/>.
            </summary>
        </member>
        <member name="M:Superpower.Parsers.Character.ExceptIn(System.Char[])">
            <summary>
            Parse any single character except those in <paramref name="chars"/>.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Character.AnyChar">
            <summary>
            Parse any character.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Character.WhiteSpace">
            <summary>
            Parse a whitespace character.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Character.Digit">
            <summary>
            Parse a digit.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Character.Letter">
            <summary>
            Parse a letter.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Character.LetterOrDigit">
            <summary>
            Parse a letter or digit.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Character.Lower">
            <summary>
            Parse a lowercase letter.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Character.Upper">
            <summary>
            Parse an uppercase letter.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Character.Numeric">
            <summary>
            Parse a numeric character.
            </summary>
        </member>
        <member name="T:Superpower.Parsers.Numerics">
            <summary>
            Parsers for numeric patterns.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Numerics.Integer">
            <summary>
            A string of digits.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Numerics.IntegerInt32">
            <summary>
            A string of digits, converted into an <see cref="T:System.Int32"/>.
            </summary>
        </member>
        <member name="T:Superpower.Parsers.Span">
            <summary>
            Parsers for spans of characters.
            </summary>
        </member>
        <member name="M:Superpower.Parsers.Span.Length(System.Int32)">
            <summary>
            Parse a span of length <paramref name="length"/>/>.
            </summary>
            <param name="length">The number of characters to parse.</param>
            <returns>The parsed span.</returns>
        </member>
        <member name="M:Superpower.Parsers.Span.EqualTo(System.String)">
            <summary>
            Match a span equal to <paramref name="text"/>.
            </summary>
            <param name="text">The text to match.</param>
            <returns>The matched text.</returns>
        </member>
        <member name="M:Superpower.Parsers.Span.EqualToIgnoreCase(System.String)">
            <summary>
            Match a span equal to <paramref name="text"/>, ignoring invariant case.
            </summary>
            <param name="text">The text to match.</param>
            <returns>The matched text.</returns>
        </member>
        <member name="M:Superpower.Parsers.Span.EqualTo(System.Char)">
            <summary>
            Match a span equal to a singe character <paramref name="ch"/>.
            </summary>
            <param name="ch">The character to match.</param>
            <returns>The matched text.</returns>
        </member>
        <member name="M:Superpower.Parsers.Span.EqualToIgnoreCase(System.Char)">
            <summary>
            Match a span equal to a singe character <paramref name="ch"/>, ignoring invariant character case.
            </summary>
            <param name="ch">The character to match.</param>
            <returns>The matched text.</returns>
        </member>
        <member name="M:Superpower.Parsers.Span.Until(System.Func{System.Char,System.Boolean})">
            <summary>
            Parse until finding a character for which <paramref name="predicate"/> returns true.
            </summary>
            <param name="predicate">A predicate.</param>
            <returns>The matched text.</returns>
        </member>
        <member name="M:Superpower.Parsers.Span.While(System.Func{System.Char,System.Boolean})">
            <summary>
            Parse until finding a character for which <paramref name="predicate"/> returns false.
            </summary>
            <param name="predicate">A predicate.</param>
            <returns>The matched text.</returns>
        </member>
        <member name="P:Superpower.Parsers.Span.WhiteSpace">
            <summary>
            Parse until a non-whitespace character is encountered, returning the matched span of whitespace.
            </summary>
        </member>
        <member name="T:Superpower.Parsers.Token">
            <summary>
            Parsers for matching individual tokens.
            </summary>
        </member>
        <member name="M:Superpower.Parsers.Token.EqualTo``1(``0)">
            <summary>
            Parse a token of the kind <typeparamref name="TKind"/>.
            </summary>
            <typeparam name="TKind">The type of the token being matched.</typeparam>
            <param name="kind">The kind of token to match.</param>
            <returns>The matched token.</returns>
        </member>
        <member name="M:Superpower.Parsers.Token.Sequence``1(``0[])">
            <summary>
            Parse a sequence of tokens of the kind <typeparamref name="TKind"/>.
            </summary>
            <typeparam name="TKind">The type of the tokens being matched.</typeparam>
            <param name="kinds">The kinds of token to match, once each in order.</param>
            <returns>The matched tokens.</returns>
        </member>
        <member name="M:Superpower.Parsers.Token.EqualToValue``1(``0,System.String)">
            <summary>
            Parse a token where the span of text matches a particular value.
            </summary>
            <param name="kind">The kind of token to match.</param>
            <param name="value">The string value to compare against the token's underlying span.</param>
            <typeparam name="TKind">The type of the token being matched.</typeparam>
            <returns>A parser that will match tokens with the specified kind and value.</returns>
        </member>
        <member name="M:Superpower.Parsers.Token.EqualToValueIgnoreCase``1(``0,System.String)">
            <summary>
            Parse a token where the span of text matches a particular value, ignoring invariant character case.
            </summary>
            <param name="kind">The kind of token to match.</param>
            <param name="value">The string value to compare against the token's underlying span.</param>
            <typeparam name="TKind">The type of the token being matched.</typeparam>
            <returns>A parser that will match tokens with the specified kind and value.</returns>
        </member>
        <member name="T:Superpower.TextParser`1">
            <summary>
            A parser that consumes text from a string span.
            </summary>
            <typeparam name="T">The type of values produced by the parser.</typeparam>
            <param name="input">The span of text to parse.</param>
            <returns>A result with a parsed value, or an empty result indicating error.</returns>
        </member>
        <member name="T:Superpower.Tokenizer`1">
            <summary>
            Base class for tokenizers, types whose instances convert strings into lists of tokens.
            </summary>
            <typeparam name="TKind">The kind of tokens produced.</typeparam>
        </member>
        <member name="M:Superpower.Tokenizer`1.Tokenize(System.String)">
            <summary>
            Tokenize <paramref name="source"/>.
            </summary>
            <param name="source">The source to tokenize.</param>
            <returns>The list of tokens or an error.</returns>
            <exception cref="T:Superpower.ParseException">Tokenization failed.</exception>
        </member>
        <member name="M:Superpower.Tokenizer`1.TryTokenize(System.String)">
            <summary>
            Tokenize <paramref name="source"/>.
            </summary>
            <param name="source">The source to tokenize.</param>
            <returns>A result with the list of tokens or an error.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is null.</exception>
            <exception cref="T:Superpower.ParseException">The tokenizer could not correctly perform tokenization.</exception>
        </member>
        <member name="P:Superpower.Tokenizer`1.Previous">
            <summary>
            The previous token parsed.
            </summary>
        </member>
        <member name="M:Superpower.Tokenizer`1.Tokenize(Superpower.Model.TextSpan)">
            <summary>
            Subclasses should override to perform tokenization.
            </summary>
            <param name="span">The input span to tokenize.</param>
            <returns>A list of parsed tokens.</returns>
        </member>
        <member name="M:Superpower.Tokenizer`1.SkipWhiteSpace(Superpower.Model.TextSpan)">
            <summary>
            Advance until the first non-whitespace character is encountered.
            </summary>
            <param name="span">The span to advance from.</param>
            <returns>A result with the first non-whitespace character.</returns>
        </member>
        <member name="T:Superpower.TokenListParser`2">
            <summary>
            A parser that consumes elements from a list of tokens.
            </summary>
            <typeparam name="T">The type of values produced by the parser.</typeparam>
            <typeparam name="TKind">The type of tokens being parsed.</typeparam>
            <param name="input">The list of tokens to parse.</param>
            <returns>A result with a parsed value, or an empty result indicating error.</returns>
        </member>
    </members>
</doc>
